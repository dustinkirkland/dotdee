#!/bin/sh -e
#
#    dotdee - convert a flat file into one dynamically generated from a .d directory
#    Copyright (C) 2010 Dustin Kirkland <kirkland@ubuntu.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

DIR="/etc/dotdee"
ORIGINAL="50-original"
COMMENT=".comment"
FORCE=

info() {
	echo "INFO: $@" 1>&2
}

error() {
	echo "ERROR: $@" 1>&2
	exit 1
}

usage() {
	echo
	echo "dotdee --dir|--original|--setup|--update|--undo FILENAME"
	echo
	echo "  -c|--comment FILENAME COMMENT_DELIM set the file comment delimiter"
	echo "  -d|--dir FILENAME	print the dotdee directory where snippets live"
	echo "  -o|--original FILENAME	print the current location of the original file"
	echo "  -s|--setup FILENAME	convert FILENAME to a .d directory structure"
	echo "  -u|--update FILENAME	update the generated FILENAME immediately"
	echo "  --undo FILENAME		undo/revert a dotdee setup"
	echo
}

u_a_name() {
	# Ensure a unique name in update-alternatives
	echo "${1}" | sed -e "s%/%:%g" -e "s%^:\+%%"
}

is_dotdee() {
	# Is this file managed by dotdee?
	u=$(u_a_name "${1}")
	update-alternatives --list "${u}" 2>/dev/null | grep -qs "^${DIR}/${1}$"
}

sync_attrs() {
	chown --reference "${1}" "${2}"
	chmod --reference "${1}" "${2}"
}

comment() {
	local tmp=$(mktemp)
	echo "${2}" > "${tmp}"
	[ -n "${3}" ] && echo "${3}" >> "${tmp}"
	mv -f "${tmp}" "${DIR}/${1}.d/${COMMENT}"
	sleep 0.1	# Ugly, but somehow this isn't getting written to disk?
}

directory() {
	if is_dotdee "${1}"; then
		echo "${DIR}/${1}.d"
	else
		error "[${1}] is not managed by dotdee"
	fi
}

original() {
	if is_dotdee "${1}"; then
		echo "${DIR}/${1}.d/${ORIGINAL}"
	else
		error "[${1}] is not managed by dotdee"
	fi
}

setup() {
	# Setup a file for dotdee management
	if is_dotdee "${1}" && [ "$FORCE" != "1" ]; then
		error "[${1}] is already managed by dotdee"
	else
		# Test for applicability
		[ -f "${1}" ] || error "Not a regular file [${1}]"
		# Create the directory and move the file
		mkdir -p "${DIR}/${1}.d"
		mv -f "${1}" "${DIR}/${1}.d/${ORIGINAL}"
		[ -n "${2}" ] && comment "${1}" "${2}" "${3}"
		NEW=1
		update "${1}"
		# Re-establish links to file
		u=$(u_a_name "${1}")
		# Establish update-alternatives link at a higher priority to the generated one
		update-alternatives --install "${1}" "${u}" "$DIR/${1}" 50
		# Establish update-alternatives link at a lower priority to the original one
		update-alternatives --install "${1}" "${u}" "$DIR/${1}.d/${ORIGINAL}" 20
	fi
}

update() {
	# Construct the file via concatenation
	if is_dotdee "${1}" || [ "${NEW}" = 1 ]; then
		tmp=$(mktemp)
		# Conditionally add the comment header to the beginning of the generated file.
		if [ -f "${DIR}/${1}.d/${COMMENT}" ]; then
			lines=$(wc -l "${DIR}/${1}.d/${COMMENT}" | awk '{print $1}')
			if [ "$lines" = "1" ]; then
				c1=$(head -n1 "${DIR}/${1}.d/${COMMENT}")
				c2=
			elif [ "$lines" = "2" ]; then
				c1=$(head -n1 "${DIR}/${1}.d/${COMMENT}")
				c2=$(tail -n1 "${DIR}/${1}.d/${COMMENT}")
				c2=" ${c2}"
			fi
			if [ "$lines" = "1" ] || [ "$lines" = "2" ]; then
				printf "${c1} DO NOT EDIT THIS FILE DIRECTLY!${c2}\n" >> "${tmp}"
				printf "${c1} Rather, add, remove, or modify file(s) in [%s]${c2}\n" "${DIR}/${1}.d" >> "${tmp}"
				printf "${c1} per the dotdee(8) manpage.${c2}\n" >> "${tmp}"
			fi
		fi
		for i in "${DIR}/${1}.d/"[0-9]*; do
			case "${i}" in
				"${DIR}/${1}.d/${ORIGINAL}")
					cat "${i}" >> "${tmp}"
				;;
				*.patch|*.diff)
					patch "${tmp}" "${i}"
				;;
				*)
					if [ -x "${i}" ]; then
						# file is not 50-original, and is executable,
						# so by convention, feed the current state
						# of the file as STDIN, and write STDOUT to
						# the file
						tmp2=$(mktemp)
						${i} <"${tmp}" >"${tmp2}"
						mv -f "${tmp2}" "${tmp}"
					else
						cat "${i}" >> "${tmp}"
					fi
				;;
			esac
		done
		mv -f "${tmp}" "$DIR/${1}"
		# Sync owner:group and permissions
		sync_attrs "${DIR}/${1}.d/${ORIGINAL}" "$DIR/${1}"
		# But then remove all write access, to prevent inadvertent writes to this generated file
		chmod a-w "$DIR/${1}"
	else
		error "[${1}] is not managed by dotdee"
	fi
}

undo() {
	# Undo a dotdee setup
	if is_dotdee "${1}"; then
		u=$(u_a_name "${1}")
		update-alternatives --remove "${u}" "${DIR}/${1}"
		update-alternatives --remove "${u}" "${DIR}/${1}.d/${ORIGINAL}"
		cp -af "${DIR}/${1}.d/${ORIGINAL}" "${1}"
		info "[${1}] has been restored"
		info "You may want to manually remove [${DIR}/${1} ${DIR}/${1}.d]"
	else
		error "[${1}] is not managed by dotdee"
	fi
}

# Main
case "${1}" in
	-c|--comment)
		comment "${2}" "${3}" "${4}"
	;;
	-d|--dir|--directory)
		directory "${2}"
	;;
	-o|--original)
		original "${2}"
	;;
	-s|--setup)
		setup "${2}" "${3}"
	;;
	--setup-force)
		FORCE=1
		setup "${2}" "${3}" "${4}"
	;;
	-u|--update)
		NEW=
		update "${2}"
	;;
	--undo)
		undo "${2}"
	;;
	--help)
		usage
	;;
	*)
		usage
		error "Invalid argument [${1}]"
	;;
esac
