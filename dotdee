#!/bin/sh -e
#
#    dotdee - convert a flat file into one dynamically generated from a .d directory
#    Copyright (C) 2010 Dustin Kirkland <kirkland@ubuntu.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

DIR="/etc/dotdee"
ORIGINAL="50-original"
PERMS=".perms"

info() {
	echo "INFO: $@" 1>&2
}

error() {
	echo "ERROR: $@" 1>&2
	exit 1
}

usage() {
	echo
	echo "dotdee --setup|--update|--undo FILENAME"
	echo
	echo "  --setup FILENAME	convert FILENAME to a .d directory structure"
	echo "  --update FILENAME	update the generated FILENAME immediately"
	echo "  --undo FILENAME		undo/revert a dotdee setup"
	echo
}

u_a_name() {
	# Ensure a unique name in update-alternatives
	echo "${1}" | sed -e "s:/:-:g" -e "s:^-\+::"
}

is_dotdee() {
	# Is this file managed by dotdee?
	u=$(u_a_name "${1}")
	update-alternatives --list "${u}" 2>/dev/null | grep -qs "^${DIR}/${1}$"
}

setup() {
	# Setup a file for dotdee management
	if is_dotdee "${1}"; then
		error "[${1}] is already managed by dotdee"
	else
		# Test for applicability
		[ -f "${1}" ] || error "Not a regular file [${1}]"
		# Create the directory and move the file
		mkdir -p "${DIR}/${1}.d"
		mv -f "${1}" "${DIR}/${1}.d/${ORIGINAL}"
		# Save the owernships/permissions of the original file
		t=$(mktemp)
		mv -f "${t}" "${DIR}/${1}.d/${PERMS}"
		chmod --reference "${DIR}/${1}.d/${ORIGINAL}" "${DIR}/${1}.d/${PERMS}"
		chown --reference "${DIR}/${1}.d/${ORIGINAL}" "${DIR}/${1}.d/${PERMS}"
		# Now make the original read-only
		chmod -w "${DIR}/${1}.d/${ORIGINAL}"
		NEW=1
		update "${1}"
		# Re-establish links to file
		u=$(u_a_name "${1}")
		# Establish update-alternatives link at a higher priority to the generated one
		update-alternatives --install "${1}" "${u}" "$DIR/${1}" 50
		# Establish update-alternatives link at a lower priority to the original one
		update-alternatives --install "${1}" "${u}" "$DIR/${1}.d/${ORIGINAL}" 20
	fi
}

update() {
	# Construct the file via concatenation
	if is_dotdee "${1}" || [ "${NEW}" = 1 ]; then
		tmp=$(mktemp)
		# BUG: We should determine the type of file, obtain the
		#      comment character, and prepend a header that documents that this
		#      file is managed by dotdee(8), as a hint to humans who try to edit!
		for i in "${DIR}/${1}.d/"*; do
			cat "${i}" >> "${tmp}"
		done
		mv -f "${tmp}" "$DIR/${1}"
		chmod --reference "${DIR}/${1}.d/${PERMS}" "$DIR/${1}"
		chown --reference "${DIR}/${1}.d/${PERMS}" "$DIR/${1}"
	else
		error "[${1}] is not managed by dotdee"
	fi
}

undo() {
	# Undo a dotdee setup
	if is_dotdee "${1}"; then
		u=$(u_a_name "${1}")
		update-alternatives --remove "${u}" "${DIR}/${1}"
		update-alternatives --remove "${u}" "${DIR}/${1}.d/${ORIGINAL}"
		cp -af "${DIR}/${1}.d/${ORIGINAL}" "${1}"
		chmod --reference "${DIR}/${1}.d/${PERMS}" "$DIR/${1}"
		chown --reference "${DIR}/${1}.d/${PERMS}" "$DIR/${1}"
		info "[${1}] has been restored"
		info "You may want to manually remove [${DIR}/${1}.d]"
	else
		error "[${1}] is not managed by dotdee"
	fi
}

# Main
case "${1}" in
	--setup)
		setup "${2}"
	;;
	--update)
		NEW=
		update "${2}"
	;;
	--undo)
		undo "${2}"
	;;
	--help)
		usage
	;;
	*)
		usage
		error "Invalid argument [${1}]"
	;;
esac
